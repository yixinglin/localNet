# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'configurepricing.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


# pyuic5 -o ui_configurepricing.py configurepricing.ui

from PyQt5.QtWidgets import QDialog, QTableWidgetItem
from views.pricing.components.ui_configurepricing import Ui_Dialog
from PyQt5.QtCore import Qt, pyqtSignal, QObject, QThread
from api.pricing import MetroPricing


class ConfigurePricing(QDialog, Ui_Dialog):

    def __init__(self, parent=None):
        super(ConfigurePricing, self).__init__(parent)
        self.setupUi(self)
        self.setFixedSize(self.size())
        self.setWindowTitle("Pricing Configuration")
        self.configureTable.setColumnWidth(0, 90)
        self.configureTable.setColumnWidth(1, 200)
        self.configureTable.setColumnWidth(2, 90)
        self.configureTable.setColumnWidth(3, 70)
        self.configureTable.setColumnWidth(4, 70)
        # self.confirmBox.clicked.connect(self.onConfirmButtonClicked)

    def appendRow(self, row: tuple):
        iRow = self.configureTable.rowCount()
        self.configureTable.setRowCount(iRow + 1)

        cell = self.createCell(iRow, 0, row[0])  # Gtin
        cell.setTextAlignment(Qt.AlignLeft)
        cellName = self.createCell(iRow, 1, row[1])  # Name
        cellName.setTextAlignment(Qt.AlignLeft)
        cell = self.createCell(iRow, 2, row[2], readOnly=False)  # Note
        cell.setTextAlignment(Qt.AlignLeft)
        cell = self.createCell(iRow, 3, f"{row[3]: .2f}", readOnly=False)  # LowestPrice
        cell.setTextAlignment(Qt.AlignRight)

        cellName.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
        cellName.setCheckState(Qt.Checked if row[4] else Qt.Unchecked)


    def removeRow(self):
        pass

    def createCell(self, r: int, c: int, val: str, readOnly=True) -> QTableWidgetItem:
        cell = QTableWidgetItem(val) if isinstance(val, str) else QTableWidgetItem(str(val))
        self.configureTable.setItem(r, c, cell)
        if readOnly:
            cell.setFlags(Qt.ItemIsEnabled)
        return cell

    def getShopName(self) -> str:
        return self.shopName.text()

    def setShopName(self, shopName: str):
        self.shopName.setText(shopName)

    def getPricingFrequency(self) -> int:
        self.pricingFreq.value()

    def setPricingFrequency(self, seconds):
        self.pricingFreq.setValue(seconds)

    def getServerURL(self) -> str:
        return self.server.text()

    def setServerURL(self, url):
        self.server.setText(url)

    def disabledInputWidgets(self, disabled=True):
        self.configureTable.setDisabled(disabled)
        self.pricingFreq.setDisabled(disabled)
        self.shopName.setDisabled(disabled)
        self.server.setDisabled(disabled)


# ============= LOGIC ====================
class Communication(QObject):
    sg_conf = pyqtSignal(dict, name="getConfiguration")
    sg_upload_conf = pyqtSignal(dict, name="uploadConfiguration")

# ----------- THREADS -------------------
class ConfigureThread(QThread):

    def __init__(self, parent=None, api=None):
        super(ConfigureThread, self).__init__(parent)
        self.api = api
        self.parent = parent

    def run(self) -> None:
        conf = self.api.fetchListConfiguration()
        self.parent.communication.sg_conf.emit(conf)

class ConfigurePricingLogic(ConfigurePricing):

    def __init__(self, parent=None):
        super(ConfigurePricingLogic, self).__init__(parent)
        self.APINAME = MetroPricing
        self.confirmBox.clicked.connect(self.onClickedConfirmButton)
        self.serverBaseURL = self.getServerURL()
        self.communication = Communication()
        self.communication.sg_conf.connect(self.fillTable)
        self.confData = {}

    def fetchConfiguration(self):
        self.serverBaseURL = self.getServerURL()
        api = self.APINAME(self.serverBaseURL)
        thread = ConfigureThread(self, api)
        thread.start()

    def fillTable(self, conf: dict):
        table = []
        self.confData = conf
        for item in conf["data"]:
            row = (item["productId"], item["productName"], item["offerNote"], item["lowestPrice"], item["enabled"])
            table.append(row)
        table = sorted(table, key=lambda o: (o[2], float(o[3])))
        for item in table:
            self.appendRow(item)

    def uploadListConfiguration(self):
        pass

    def onClickedConfirmButton(self):
        self.disabledInputWidgets(True)
        self.disabledInputWidgets(False)
